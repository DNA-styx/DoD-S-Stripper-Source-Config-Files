# Deploy changed .cfg files via SFTP (improved upload diagnostics)
name: Deploy changed .cfg files via SFTP

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      run_mode:
        description: 'Run mode: "changed" (only files changed in the push) or "full" (upload all tracked .cfg files under REPO_PREFIX).'
        required: false
        default: 'full'
      dry_run:
        description: 'If "true", only print actions (no ssh/scp). Useful for testing.'
        required: false
        default: 'true'
      ref:
        description: 'Branch/ref to checkout when running manually (optional).'
        required: false
        default: 'main'

jobs:
  deploy:
    runs-on: ubuntu-latest

    env:
      REPO_PREFIX: 'addons/sourcemod/configs/stripper'
      VERBOSE: 'true'

      SERVER1_HOST: ${{ secrets.SERVER1_HOST }}
      SERVER1_USER: ${{ secrets.SERVER1_USER }}
      SERVER1_PASS: ${{ secrets.SERVER1_PASS }}
      SERVER1_REMOTE_BASE: ${{ secrets.SERVER1_REMOTE_BASE }}
      SERVER1_PORT: ${{ secrets.SERVER1_PORT }}

      SERVER2_HOST: ${{ secrets.SERVER2_HOST }}
      SERVER2_USER: ${{ secrets.SERVER2_USER }}
      SERVER2_PASS: ${{ secrets.SERVER2_PASS }}
      SERVER2_REMOTE_BASE: ${{ secrets.SERVER2_REMOTE_BASE }}
      SERVER2_PORT: ${{ secrets.SERVER2_PORT }}

      SERVER3_HOST: ${{ secrets.SERVER3_HOST }}
      SERVER3_USER: ${{ secrets.SERVER3_USER }}
      SERVER3_PASS: ${{ secrets.SERVER3_PASS }}
      SERVER3_REMOTE_BASE: ${{ secrets.SERVER3_REMOTE_BASE }}
      SERVER3_PORT: ${{ secrets.SERVER3_PORT }}

    steps:
      - name: "Checkout repository (full history)"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: "Optionally checkout requested ref (workflow_dispatch)"
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.ref != '' }}
        run: |
          REF="${{ github.event.inputs.ref }}"
          echo "workflow_dispatch requested ref: $REF"
          git fetch origin "$REF" --depth=1 || true
          git checkout "$REF" || git checkout -b "$REF" "origin/$REF" || true

      - name: "Install sshpass"
        run: |
          sudo apt-get update
          sudo apt-get install -y sshpass

      - name: "Determine changed .cfg files (robust)"
        id: changed
        env:
          RUN_MODE: ${{ github.event.inputs.run_mode }}
          BEFORE: ${{ github.event.before }}
          AFTER: ${{ github.sha }}
        run: |
          set -euo pipefail
          RUN_MODE="${RUN_MODE:-changed}"
          BEFORE="${BEFORE}"
          AFTER="${AFTER}"
          REPO_PREFIX="${REPO_PREFIX%/}"
          echo "RUN_MODE=$RUN_MODE BEFORE=$BEFORE AFTER=$AFTER REPO_PREFIX=$REPO_PREFIX"

          git fetch --no-tags --prune origin || true
          if [ -n "$BEFORE" ] && [ "$BEFORE" != "0000000000000000000000000000000000000000" ]; then
            git fetch origin "$BEFORE":"refs/remotes/origin/$BEFORE" || true
          fi
          if [ -n "$AFTER" ]; then
            git fetch origin "$AFTER":"refs/remotes/origin/$AFTER" || true
          fi

          if [ "$RUN_MODE" = "full" ] || [ -z "$BEFORE" ] || [ "$BEFORE" = "0000000000000000000000000000000000000000" ]; then
            (git ls-tree -r --name-only "${AFTER}" \
              | grep -E -i "^${REPO_PREFIX}(/|$)" \
              | grep -E -i '\.cfg$') > changed.txt || true
          else
            (git --no-pager diff --name-only "$BEFORE" "$AFTER" \
              | grep -E -i "^${REPO_PREFIX}(/|$)" \
              | grep -E -i '\.cfg$') > changed.txt || true
            if [ ! -s changed.txt ]; then
              (git ls-tree -r --name-only "${AFTER}" \
                | grep -E -i "^${REPO_PREFIX}(/|$)" \
                | grep -E -i '\.cfg$') > changed.txt || true
            fi
          fi

          touch changed.txt
          echo "Changed files:"
          nl -ba changed.txt || true
          echo "files=$(wc -l < changed.txt || true)" >> "$GITHUB_OUTPUT"

      - name: "Upload / remove changed .cfg files (upload from commit with diagnostics)"
        if: ${{ always() }}
        env:
          DRY_RUN: ${{ github.event.inputs.dry_run }}
          AFTER: ${{ github.sha }}
        run: |
          set -euo pipefail
          DRY_RUN="${DRY_RUN:-true}"
          REPO_PREFIX="${REPO_PREFIX%/}"
          AFTER="${AFTER}"

          if [ ! -s changed.txt ]; then
            echo "No files to process; exiting."
            exit 0
          fi

          nl -ba changed.txt || true
          echo "----"

          while IFS= read -r f || [ -n "$f" ]; do
            [ -z "$f" ] && continue
            echo "Processing: '$f'"

            case "$f" in
              "$REPO_PREFIX" | "$REPO_PREFIX/"* )
                if [ "$f" = "$REPO_PREFIX" ]; then
                  relpath="$(basename "$f")"
                else
                  relpath="${f#${REPO_PREFIX}/}"
                fi
                ;;
              *)
                echo "  Skipping (not under REPO_PREFIX)"
                continue
                ;;
            esac

            echo "  relpath='$relpath'"
            if ! echo "$relpath" | grep -E -i '\.cfg$' >/dev/null 2>&1; then
              echo "  Skipping (not .cfg)"
              continue
            fi

            if git --no-pager ls-files --error-unmatch "$f" >/dev/null 2>&1; then
              echo "  Present in commit — will upload from commit object"
              for i in 1 2 3; do
                HOST_VAR="SERVER${i}_HOST"; HOST="${!HOST_VAR:-}"
                if [ -z "$HOST" ]; then
                  continue
                fi
                USER_VAR="SERVER${i}_USER"; PASS_VAR="SERVER${i}_PASS"; RB_VAR="SERVER${i}_REMOTE_BASE"; PORT_VAR="SERVER${i}_PORT"
                USER="${!USER_VAR:-}"; PASS="${!PASS_VAR:-}"; REMOTE_BASE="${!RB_VAR:-}"; PORT="${!PORT_VAR:-22}"
                if [ -z "$USER" ] || [ -z "$PASS" ] || [ -z "$REMOTE_BASE" ]; then
                  echo "  Server $i missing USER/PASS/REMOTE_BASE — skipping"
                  continue
                fi

                remote_target="${REMOTE_BASE%/}/$relpath"
                remote_dir="$(dirname "$remote_target")"

                echo "  Server $i: host=$HOST user=$USER target=$remote_target"

                if [ "$DRY_RUN" = "true" ]; then
                  echo "    [DRY] would: mkdir -p $remote_dir ; scp <tmpfile> -> $remote_target"
                  continue
                fi

                # create remote dir
                echo "    Ensuring remote dir: ssh -p ${PORT:-22} $USER@$HOST mkdir -p '$remote_dir'"
                sshpass -p "$PASS" ssh -p "${PORT:-22}" -o StrictHostKeyChecking=no "$USER@$HOST" "mkdir -p '$remote_dir'" || echo "    Warning: mkdir on $HOST returned non-zero"

                # attempt git show -> temp file
                tmpf="$(mktemp)"
                echo "    git show '${AFTER}:$f' -> $tmpf"
                if git show "${AFTER}:$f" > "$tmpf" 2> "$tmpf.err"; then
                  echo "    git show OK (size: $(stat -c%s "$tmpf"))"
                else
                  echo "    git show FAILED exit=$? ; stderr:"
                  sed -n '1,200p' "$tmpf.err" || true
                  rm -f "$tmpf" "$tmpf.err"
                  # fallback: try to checkout the file into workspace and upload from there
                  echo "    Fallback: trying 'git checkout ${AFTER} -- \"$f\"' into worktree"
                  if git checkout "${AFTER}" -- "$f" 2> /tmp/gitcheckout.err; then
                    echo "    git checkout succeeded; will upload from workspace path '$f'"
                    echo "    ls -l '$f':"
                    ls -l "$f" || true
                    tmpf=""  # indicate using workspace file
                  else
                    echo "    git checkout failed; stderr:"
                    sed -n '1,200p' /tmp/gitcheckout.err || true
                    echo "    Skipping upload for this server"
                    continue
                  fi
                fi

                # perform scp and capture stderr+exit code
                if [ -n "$tmpf" ]; then
                  echo "    scp $tmpf -> $USER@$HOST:$remote_target"
                  if sshpass -p "$PASS" scp -P "${PORT:-22}" -p "$tmpf" "$USER@$HOST:$remote_target" 2> "$tmpf.scp.err"; then
                    echo "    scp succeeded"
                    rm -f "$tmpf" "$tmpf.err" "$tmpf.scp.err" || true
                  else
                    echo "    scp FAILED exit=$? ; stderr:"
                    sed -n '1,200p' "$tmpf.scp.err" || true
                    rm -f "$tmpf" "$tmpf.err" "$tmpf.scp.err" || true
                  fi
                else
                  # using workspace file path $f
                  echo "    scp $f -> $USER@$HOST:$remote_target"
                  if sshpass -p "$PASS" scp -P "${PORT:-22}" -p "$f" "$USER@$HOST:$remote_target" 2> /tmp/scp.err; then
                    echo "    scp succeeded (from workspace)"
                    rm -f /tmp/scp.err || true
                  else
                    echo "    scp FAILED ; stderr:"
                    sed -n '1,200p' /tmp/scp.err || true
                    rm -f /tmp/scp.err || true
                  fi
                fi
              done
            else
              echo "  NOT present in commit (treated as deleted) — will remove remote entries"
              for i in 1 2 3; do
                HOST_VAR="SERVER${i}_HOST"; HOST="${!HOST_VAR:-}"
                if [ -z "$HOST" ]; then
                  continue
                fi
                USER_VAR="SERVER${i}_USER"; PASS_VAR="SERVER${i}_PASS"; RB_VAR="SERVER${i}_REMOTE_BASE"; PORT_VAR="SERVER${i}_PORT"
                USER="${!USER_VAR:-}"; PASS="${!PASS_VAR:-}"; REMOTE_BASE="${!RB_VAR:-}"; PORT="${!PORT_VAR:-22}"
                if [ -z "$USER" ] || [ -z "$PASS" ] || [ -z "$REMOTE_BASE" ]; then
                  echo "  Server $i missing USER/PASS/REMOTE_BASE — skipping"
                  continue
                fi
                remote_target="${REMOTE_BASE%/}/$relpath"
                if [ "$DRY_RUN" = "true" ]; then
                  echo "    [DRY] Would remove $remote_target on $HOST"
                else
                  echo "    Removing $remote_target on $HOST"
                  sshpass -p "$PASS" ssh -p "${PORT:-22}" -o StrictHostKeyChecking=no "$USER@$HOST" "rm -f '$remote_target' || true" || echo "    Warning: remote rm returned non-zero"
                fi
              done
            fi

            echo "----"
          done < changed.txt

      - name: "Summary"
        if: ${{ always() }}
        run: |
          echo "Workflow finished."
          if [ "${{ github.event.inputs.dry_run }}" = "true" ]; then
            echo "This was a dry run; re-run with dry_run = false to upload."
          fi