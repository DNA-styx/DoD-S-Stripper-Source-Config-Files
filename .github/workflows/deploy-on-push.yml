name: Deploy changed .cfg files via SFTP (robust, verbose)

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      run_mode:
        description: 'Run mode: "changed" (only files changed in the push) or "full" (upload all tracked .cfg files under REPO_PREFIX).'
        required: false
        default: 'full'
      dry_run:
        description: 'If "true", only print actions (no ssh/scp). Useful for testing.'
        required: false
        default: 'true'
      ref:
        description: 'Branch/ref to checkout when running manually (optional).'
        required: false
        default: 'main'

jobs:
  deploy:
    runs-on: ubuntu-latest

    env:
      REPO_PREFIX: 'addons/sourcemod/configs/stripper'
      VERBOSE: 'true'

      SERVER1_HOST: ${{ secrets.SERVER1_HOST }}
      SERVER1_USER: ${{ secrets.SERVER1_USER }}
      SERVER1_PASS: ${{ secrets.SERVER1_PASS }}
      SERVER1_REMOTE_BASE: ${{ secrets.SERVER1_REMOTE_BASE }}
      SERVER1_PORT: ${{ secrets.SERVER1_PORT }}

      SERVER2_HOST: ${{ secrets.SERVER2_HOST }}
      SERVER2_USER: ${{ secrets.SERVER2_USER }}
      SERVER2_PASS: ${{ secrets.SERVER2_PASS }}
      SERVER2_REMOTE_BASE: ${{ secrets.SERVER2_REMOTE_BASE }}
      SERVER2_PORT: ${{ secrets.SERVER2_PORT }}

      SERVER3_HOST: ${{ secrets.SERVER3_HOST }}
      SERVER3_USER: ${{ secrets.SERVER3_USER }}
      SERVER3_PASS: ${{ secrets.SERVER3_PASS }}
      SERVER3_REMOTE_BASE: ${{ secrets.SERVER3_REMOTE_BASE }}
      SERVER3_PORT: ${{ secrets.SERVER3_PORT }}

    steps:
      - name: Checkout repository (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Optionally checkout requested ref (workflow_dispatch)
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.ref != '' }}
        run: |
          REF="${{ github.event.inputs.ref }}"
          echo "workflow_dispatch requested ref: $REF"
          git fetch origin "$REF" --depth=1 || true
          git checkout "$REF" || git checkout -b "$REF" "origin/$REF" || true

      - name: Install sshpass
        run: |
          sudo apt-get update
          sudo apt-get install -y sshpass

      - name: Determine changed .cfg files (robust)
        id: changed
        env:
          RUN_MODE: ${{ github.event.inputs.run_mode }}
          BEFORE: ${{ github.event.before }}
          AFTER: ${{ github.sha }}
        run: |
          set -euo pipefail
          RUN_MODE="${RUN_MODE:-changed}"
          BEFORE="${BEFORE}"
          AFTER="${AFTER}"
          REPO_PREFIX="${REPO_PREFIX%/}"
          echo "RUN_MODE=$RUN_MODE BEFORE=$BEFORE AFTER=$AFTER REPO_PREFIX=$REPO_PREFIX"

          git fetch --no-tags --prune origin || true
          if [ -n "$BEFORE" ] && [ "$BEFORE" != "0000000000000000000000000000000000000000" ]; then
            git fetch origin "$BEFORE":"refs/remotes/origin/$BEFORE" || true
          fi
          if [ -n "$AFTER" ]; then
            git fetch origin "$AFTER":"refs/remotes/origin/$AFTER" || true
          fi

          if [ "$RUN_MODE" = "full" ] || [ -z "$BEFORE" ] || [ "$BEFORE" = "0000000000000000000000000000000000000000" ]; then
            (git ls-tree -r --name-only "${AFTER}" \
              | grep -E -i "^${REPO_PREFIX}(/|$)" \
              | grep -E -i '\.cfg$') > changed.txt || true
          else
            (git --no-pager diff --name-only "$BEFORE" "$AFTER" \
              | grep -E -i "^${REPO_PREFIX}(/|$)" \
              | grep -E -i '\.cfg$') > changed.txt || true
            if [ ! -s changed.txt ]; then
              (git ls-tree -r --name-only "${AFTER}" \
                | grep -E -i "^${REPO_PREFIX}(/|$)" \
                | grep -E -i '\.cfg$') > changed.txt || true
            fi
          fi

          touch changed.txt
          echo "Changed files:"
          nl -ba changed.txt || true
          echo "files=$(wc -l < changed.txt || true)" >> "$GITHUB_OUTPUT"

      - name: Upload / remove changed .cfg files (from commit content; tolerant)
        if: ${{ always() }}
        env:
          DRY_RUN: ${{ github.event.inputs.dry_run }}
          AFTER: ${{ github.sha }}
        run: |
          # Do not let one failing file/command exit the whole step; we handle errors per-file.
          set -u
          DRY_RUN="${DRY_RUN:-true}"
          REPO_PREFIX="${REPO_PREFIX%/}"
          AFTER="${AFTER}"

          if [ ! -s changed.txt ]; then
            echo "No files to process; exiting."
            exit 0
          fi

          nl -ba changed.txt || true
          echo "----"

          # Loop files
          while IFS= read -r f || [ -n "$f" ]; do
            [ -z "$f" ] && continue
            echo "Processing: '$f'"

            # Compute relpath
            case "$f" in
              "$REPO_PREFIX" | "$REPO_PREFIX/"* )
                if [ "$f" = "$REPO_PREFIX" ]; then
                  relpath="$(basename "$f")"
                else
                  relpath="${f#${REPO_PREFIX}/}"
                fi
                ;;
              *)
                echo "  Skipping (not under REPO_PREFIX)"
                continue
                ;;
            esac

            echo "  relpath='$relpath'"

            if ! echo "$relpath" | grep -E -i '\.cfg$' >/dev/null 2>&1; then
              echo "  Skipping (not .cfg)"
              continue
            fi

            # Present in commit?
            if git --no-pager ls-files --error-unmatch "$f" >/dev/null 2>&1; then
              echo "  Present in commit — will upload from commit object"

              for i in 1 2 3; do
                HOST_VAR="SERVER${i}_HOST"; HOST="${!HOST_VAR:-}"
                if [ -z "$HOST" ]; then
                  continue
                fi
                USER_VAR="SERVER${i}_USER"; PASS_VAR="SERVER${i}_PASS"; RB_VAR="SERVER${i}_REMOTE_BASE"; PORT_VAR="SERVER${i}_PORT"
                USER="${!USER_VAR:-}"; PASS="${!PASS_VAR:-}"; REMOTE_BASE="${!RB_VAR:-}"; PORT="${!PORT_VAR:-22}"
                if [ -z "$USER" ] || [ -z "$PASS" ] || [ -z "$REMOTE_BASE" ]; then
                  echo "  Server $i missing USER/PASS/REMOTE_BASE — skipping"
                  continue
                fi

                remote_target="${REMOTE_BASE%/}/$relpath"
                remote_dir="$(dirname "$remote_target")"

                echo "  Server $i: host=$HOST user=$USER target=$remote_target"

                if [ "$DRY_RUN" = "true" ]; then
                  echo "    [DRY] would: ssh $USER@$HOST mkdir -p '$remote_dir' ; scp <tmpfile> -> $remote_target"
                  continue
                fi

                # Ensure remote dir (capture stdout/stderr and exit code)
                echo "    Running mkdir on remote: ssh -p ${PORT:-22} $USER@$HOST mkdir -p '$remote_dir'"
                mkdir_out="$(sshpass -p "$PASS" ssh -p "${PORT:-22}" -o StrictHostKeyChecking=no "$USER@$HOST" "mkdir -p '$remote_dir'" 2>&1)"
                mkdir_rc=$?
                echo "    mkdir rc=$mkdir_rc"
                if [ -n "$mkdir_out" ]; then
                  echo "    mkdir output:"
                  sed -n '1,200p' <(printf '%s\n' "$mkdir_out") || true
                fi

                # Attempt to extract file contents from commit
                tmpf="$(mktemp)" || { echo "    mktemp failed"; continue; }
                git_show_err="/tmp/gitshow.err.$$"
                git show "${AFTER}:$f" > "$tmpf" 2> "$git_show_err"
                git_show_rc=$?
                if [ $git_show_rc -ne 0 ]; then
                  echo "    git show failed rc=$git_show_rc ; stderr:"
                  sed -n '1,200p' "$git_show_err" || true
                  rm -f "$git_show_err" "$tmpf"
                  # Try fallback: checkout file into workspace
                  echo "    Fallback: git checkout ${AFTER} -- \"$f\""
                  checkout_err="/tmp/gitcheckout.err.$$"
                  if git checkout "${AFTER}" -- "$f" 2> "$checkout_err"; then
                    echo "    git checkout succeeded; will upload from workspace path '$f'"
                    upload_src="$f"
                  else
                    echo "    git checkout failed; stderr:"
                    sed -n '1,200p' "$checkout_err" || true
                    rm -f "$checkout_err"
                    echo "    Skipping upload for this server"
                    continue
                  fi
                else
                  echo "    git show OK (size: $(stat -c%s "$tmpf") bytes)"
                  upload_src="$tmpf"
                fi

                # scp and capture stderr
                scp_err="/tmp/scp.err.$$"
                echo "    scp $upload_src -> $USER@$HOST:$remote_target"
                sshpass -p "$PASS" scp -P "${PORT:-22}" -p "$upload_src" "$USER@$HOST:$remote_target" 2> "$scp_err"
                scp_rc=$?
                if [ $scp_rc -ne 0 ]; then
                  echo "    scp FAILED rc=$scp_rc ; stderr:"
                  sed -n '1,200p' "$scp_err" || true
                else
                  echo "    scp succeeded"
                fi
                rm -f "$scp_err" || true

                # clean up temp file if we created one
                if [ "$upload_src" = "$tmpf" ] && [ -f "$tmpf" ]; then
                  rm -f "$tmpf" || true
                fi
                rm -f "$git_show_err" || true
              done

            else
              echo "  NOT present in commit (deleted) — will remove remote entries"
              for i in 1 2 3; do
                HOST_VAR="SERVER${i}_HOST"; HOST="${!HOST_VAR:-}"
                if [ -z "$HOST" ]; then
                  continue
                fi
                USER_VAR="SERVER${i}_USER"; PASS_VAR="SERVER${i}_PASS"; RB_VAR="SERVER${i}_REMOTE_BASE"; PORT_VAR="SERVER${i}_PORT"
                USER="${!USER_VAR:-}"; PASS="${!PASS_VAR:-}"; REMOTE_BASE="${!RB_VAR:-}"; PORT="${!PORT_VAR:-22}"
                if [ -z "$USER" ] || [ -z "$PASS" ] || [ -z "$REMOTE_BASE" ]; then
                  echo "  Server $i missing USER/PASS/REMOTE_BASE — skipping"
                  continue
                fi
                remote_target="${REMOTE_BASE%/}/$relpath"
                if [ "$DRY_RUN" = "true" ]; then
                  echo "    [DRY] Would remove $remote_target on $HOST"
                else
                  rm_out="$(sshpass -p "$PASS" ssh -p "${PORT:-22}" -o StrictHostKeyChecking=no "$USER@$HOST" "rm -f '$remote_target' || true" 2>&1)"
                  rm_rc=$?
                  echo "    remote rm rc=$rm_rc"
                  if [ -n "$rm_out" ]; then
                    echo "    remote rm output:"
                    sed -n '1,200p' <(printf '%s\n' "$rm_out") || true
                  fi
                fi
              done
            fi

            echo "----"
          done < changed.txt

      - name: Summary
        if: ${{ always() }}
        run: |
          echo "Workflow finished."
          if [ "${{ github.event.inputs.dry_run }}" = "true" ]; then
            echo "This was a dry run; re-run with dry_run = false to upload."
          fi