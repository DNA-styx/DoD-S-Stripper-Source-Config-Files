name: Deploy changed .cfg files via SFTP (push-only, path-filtered)

on:
  push:
    branches:
      - main
    paths:
      - 'addons/sourcemod/configs/stripper/**'

jobs:
  deploy:
    runs-on: ubuntu-latest

    env:
      REPO_PREFIX: 'addons/sourcemod/configs/stripper'

      # Server 1 (required)
      SERVER1_HOST: ${{ secrets.SERVER1_HOST }}
      SERVER1_USER: ${{ secrets.SERVER1_USER }}
      SERVER1_PASS: ${{ secrets.SERVER1_PASS }}
      SERVER1_REMOTE_BASE: ${{ secrets.SERVER1_REMOTE_BASE }}
      SERVER1_PORT: ${{ secrets.SERVER1_PORT }}

      # Server 2 (optional)
      SERVER2_HOST: ${{ secrets.SERVER2_HOST }}
      SERVER2_USER: ${{ secrets.SERVER2_USER }}
      SERVER2_PASS: ${{ secrets.SERVER2_PASS }}
      SERVER2_REMOTE_BASE: ${{ secrets.SERVER2_REMOTE_BASE }}
      SERVER2_PORT: ${{ secrets.SERVER2_PORT }}

      # Server 3 (optional)
      SERVER3_HOST: ${{ secrets.SERVER3_HOST }}
      SERVER3_USER: ${{ secrets.SERVER3_USER }}
      SERVER3_PASS: ${{ secrets.SERVER3_PASS }}
      SERVER3_REMOTE_BASE: ${{ secrets.SERVER3_REMOTE_BASE }}
      SERVER3_PORT: ${{ secrets.SERVER3_PORT }}

    steps:
      - name: Checkout repository (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install sshpass
        run: |
          sudo apt-get update -y
          sudo apt-get install -y sshpass

      - name: Determine changed .cfg files (changed-only)
        id: changed
        env:
          BEFORE: ${{ github.event.before }}
          AFTER: ${{ github.sha }}
        run: |
          set -euo pipefail
          REPO_PREFIX="${REPO_PREFIX%/}"
          BEFORE="${BEFORE}"
          AFTER="${AFTER}"
          echo "Detecting .cfg changes under '${REPO_PREFIX}' between $BEFORE -> $AFTER"

          # Ensure commits available
          git fetch --no-tags --prune origin || true
          if [ -n "$BEFORE" ] && [ "$BEFORE" != "0000000000000000000000000000000000000000" ]; then
            git fetch origin "$BEFORE":"refs/remotes/origin/$BEFORE" || true
          fi
          git fetch origin "$AFTER":"refs/remotes/origin/$AFTER" || true

          # Changed-only mode: list changed .cfg files between BEFORE and AFTER
          git --no-pager diff --name-only "$BEFORE" "$AFTER" \
            | grep -E -i "^${REPO_PREFIX}(/|$)" \
            | grep -E -i '\.cfg$' > changed.txt || true

          # Ensure changed.txt exists
          touch changed.txt

          files_count=$(wc -l < changed.txt || echo 0)
          echo "Found $files_count changed .cfg files:"
          sed -n '1,200p' changed.txt || true

          echo "files=${files_count}" >> "$GITHUB_OUTPUT"

      - name: Upload changed .cfg files via SFTP (sequential, retries)
        if: ${{ steps.changed.outputs.files != '0' }}
        env:
          AFTER: ${{ github.sha }}
        run: |
          set -euo pipefail
          REPO_PREFIX="${REPO_PREFIX%/}"
          AFTER="${AFTER}"
          RETRIES=2   # 2 retries on failure (total attempts = 1 + RETRIES)

          echo "Uploading files listed in changed.txt"

          while IFS= read -r f || [ -n "$f" ]; do
            [ -z "$f" ] && continue

            # compute relpath relative to REPO_PREFIX
            case "$f" in
              "$REPO_PREFIX" | "$REPO_PREFIX/"* )
                if [ "$f" = "$REPO_PREFIX" ]; then
                  relpath="$(basename "$f")"
                else
                  relpath="${f#${REPO_PREFIX}/}"
                fi
                ;;
              *)
                echo "Skipping (not under REPO_PREFIX): $f"
                continue
                ;;
            esac

            # only handle .cfg files
            if ! echo "$relpath" | grep -E -i '\.cfg$' >/dev/null 2>&1; then
              echo "Skipping (not .cfg): $f"
              continue
            fi

            # Ensure file exists in the AFTER commit
            if ! git cat-file -e "${AFTER}:$f" 2>/dev/null; then
              echo "Skipping '${f}' — not present in commit ${AFTER}"
              continue
            fi

            echo "Processing: $f -> $relpath"

            # write file contents from commit to temp file
            tmpf="$(mktemp)" || { echo "mktemp failed"; exit 1; }
            if ! git show "${AFTER}:$f" > "$tmpf" 2>/dev/null; then
              echo "ERROR: git show failed for ${f}; skipping"
              rm -f "$tmpf"
              continue
            fi

            # Upload to configured servers sequentially
            for i in 1 2 3; do
              HOST_VAR="SERVER${i}_HOST"; HOST="${!HOST_VAR:-}"
              [ -z "$HOST" ] && continue

              USER_VAR="SERVER${i}_USER"; PASS_VAR="SERVER${i}_PASS"; RB_VAR="SERVER${i}_REMOTE_BASE"; PORT_VAR="SERVER${i}_PORT"
              USER="${!USER_VAR:-}"; PASS="${!PASS_VAR:-}"; REMOTE_BASE="${!RB_VAR:-}"; PORT="${!PORT_VAR:-}"

              # per requirement: always use SERVERi_PORT (must be set)
              if [ -z "$PORT" ]; then
                echo "ERROR: SERVER${i}_PORT is not set; aborting (per workflow configuration server ports are required)."
                rm -f "$tmpf"
                exit 1
              fi

              if [ -z "$USER" ] || [ -z "$PASS" ] || [ -z "$REMOTE_BASE" ]; then
                echo "Server $i missing USER / PASS / REMOTE_BASE - skipping server $i"
                continue
              fi

              remote_target="${REMOTE_BASE%/}/$relpath"
              remote_dir="$(dirname "$remote_target")"

              echo "  Server${i}: $HOST (upload to $remote_target) — attempts up to $((RETRIES+1))"

              # build sftp batchfile to create directories (mkdir may error if already exists) and put file
              batchf="$(mktemp)"
              # create each intermediate directory (sftp mkdir doesn't support -p)
              # produce absolute path components
              # handle leading slash
              IFS='/' read -r -a parts <<< "$remote_dir"
              cur=""
              for seg in "${parts[@]}"; do
                if [ -z "$seg" ]; then
                  # leading slash -> start cur with /
                  if [ -z "$cur" ]; then
                    cur="/"
                  fi
                  continue
                fi
                if [ "$cur" = "/" ]; then
                  cur="/$seg"
                else
                  cur="${cur}/$seg"
                fi
                printf 'mkdir "%s"\n' "$cur" >> "$batchf"
              done
              # upload file to exact remote path
              printf 'put "%s" "%s"\n' "$tmpf" "$remote_target" >> "$batchf"

              attempt=0
              success=0
              while [ $attempt -le $RETRIES ]; do
                # run sftp with sshpass and explicit port
                # use -oStrictHostKeyChecking=no per user preference
                sshpass -p "$PASS" sftp -oStrictHostKeyChecking=no -oPort="$PORT" -b "$batchf" "$USER@$HOST" >/tmp/sftp.out.$$ 2>/tmp/sftp.err.$$ || true
                rc=$?
                if [ $rc -eq 0 ]; then
                  success=1
                  break
                else
                  attempt=$((attempt+1))
                  echo "    attempt $attempt failed (rc=$rc)."
                  # small backoff
                  sleep 1
                fi
              done

              if [ $success -eq 1 ]; then
                echo "    uploaded to $HOST:$remote_target"
              else
                echo "    ERROR: all attempts failed for $HOST (see /tmp/sftp.err.$$ and /tmp/sftp.out.$$)"
                # print a short excerpt of sftp stderr for debugging ( concise )
                sed -n '1,50p' /tmp/sftp.err.$$ || true
                rm -f /tmp/sftp.err.$$ /tmp/sftp.out.$$ "$batchf" "$tmpf" || true
                exit 1
              fi

              rm -f /tmp/sftp.err.$$ /tmp/sftp.out.$$ "$batchf" || true
            done

            rm -f "$tmpf"
          done < changed.txt

          echo "All changed files uploaded."

      - name: Summary
        run: |
          echo "Workflow finished."